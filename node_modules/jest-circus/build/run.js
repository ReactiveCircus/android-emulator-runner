'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

var _types = require('./types');

var _state = require('./state');

var _utils = require('./utils');

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

const run = async () => {
  const {rootDescribeBlock} = (0, _state.getState)();
  (0, _state.dispatch)({
    name: 'run_start'
  });
  await _runTestsForDescribeBlock(rootDescribeBlock);
  (0, _state.dispatch)({
    name: 'run_finish'
  });
  return (0, _utils.makeRunResult)(
    (0, _state.getState)().rootDescribeBlock,
    (0, _state.getState)().unhandledErrors
  );
};

const _runTestsForDescribeBlock = async describeBlock => {
  (0, _state.dispatch)({
    describeBlock,
    name: 'run_describe_start'
  });
  const {beforeAll, afterAll} = (0, _utils.getAllHooksForDescribe)(
    describeBlock
  );

  for (const hook of beforeAll) {
    await _callCircusHook({
      describeBlock,
      hook
    });
  } // Tests that fail and are retried we run after other tests

  const retryTimes = parseInt(global[_types.RETRY_TIMES], 10) || 0;
  const deferredRetryTests = [];

  for (const test of describeBlock.tests) {
    const hasErrorsBeforeTestRun = test.errors.length > 0;
    await _runTest(test);

    if (
      hasErrorsBeforeTestRun === false &&
      retryTimes > 0 &&
      test.errors.length > 0
    ) {
      deferredRetryTests.push(test);
    }
  } // Re-run failed tests n-times if configured

  for (const test of deferredRetryTests) {
    let numRetriesAvailable = retryTimes;

    while (numRetriesAvailable > 0 && test.errors.length > 0) {
      // Clear errors so retries occur
      (0, _state.dispatch)({
        name: 'test_retry',
        test
      });
      await _runTest(test);
      numRetriesAvailable--;
    }
  }

  for (const child of describeBlock.children) {
    await _runTestsForDescribeBlock(child);
  }

  for (const hook of afterAll) {
    await _callCircusHook({
      describeBlock,
      hook
    });
  }

  (0, _state.dispatch)({
    describeBlock,
    name: 'run_describe_finish'
  });
};

const _runTest = async test => {
  (0, _state.dispatch)({
    name: 'test_start',
    test
  });
  const testContext = Object.create(null);
  const {hasFocusedTests, testNamePattern} = (0, _state.getState)();
  const isSkipped =
    test.mode === 'skip' ||
    (hasFocusedTests && test.mode !== 'only') ||
    (testNamePattern && !testNamePattern.test((0, _utils.getTestID)(test)));

  if (isSkipped) {
    (0, _state.dispatch)({
      name: 'test_skip',
      test
    });
    return;
  }

  if (test.mode === 'todo') {
    (0, _state.dispatch)({
      name: 'test_todo',
      test
    });
    return;
  }

  const {afterEach, beforeEach} = (0, _utils.getEachHooksForTest)(test);

  for (const hook of beforeEach) {
    if (test.errors.length) {
      // If any of the before hooks failed already, we don't run any
      // hooks after that.
      break;
    }

    await _callCircusHook({
      hook,
      test,
      testContext
    });
  }

  await _callCircusTest(test, testContext);

  for (const hook of afterEach) {
    await _callCircusHook({
      hook,
      test,
      testContext
    });
  } // `afterAll` hooks should not affect test status (pass or fail), because if
  // we had a global `afterAll` hook it would block all existing tests until
  // this hook is executed. So we dispatch `test_done` right away.

  (0, _state.dispatch)({
    name: 'test_done',
    test
  });
};

const _callCircusHook = ({hook, test, describeBlock, testContext}) => {
  (0, _state.dispatch)({
    hook,
    name: 'hook_start'
  });
  const timeout = hook.timeout || (0, _state.getState)().testTimeout;
  return (0, _utils.callAsyncCircusFn)(hook.fn, testContext, {
    isHook: true,
    timeout
  })
    .then(() =>
      (0, _state.dispatch)({
        describeBlock,
        hook,
        name: 'hook_success',
        test
      })
    )
    .catch(error =>
      (0, _state.dispatch)({
        describeBlock,
        error,
        hook,
        name: 'hook_failure',
        test
      })
    );
};

const _callCircusTest = (test, testContext) => {
  (0, _state.dispatch)({
    name: 'test_fn_start',
    test
  });
  const timeout = test.timeout || (0, _state.getState)().testTimeout;
  (0, _utils.invariant)(
    test.fn,
    `Tests with no 'fn' should have 'mode' set to 'skipped'`
  );

  if (test.errors.length) {
    // We don't run the test if there's already an error in before hooks.
    return Promise.resolve();
  }

  return (0, _utils.callAsyncCircusFn)(test.fn, testContext, {
    isHook: false,
    timeout
  })
    .then(() =>
      (0, _state.dispatch)({
        name: 'test_fn_success',
        test
      })
    )
    .catch(error =>
      (0, _state.dispatch)({
        error,
        name: 'test_fn_failure',
        test
      })
    );
};

var _default = run;
exports.default = _default;
